# Gemini API統合

## 概要

このドキュメントは、RSS記事キュレーションBotにおけるGemini API統合の技術的な詳細を説明します。

### 使用モデル

- **モデル**: `gemini-1.5-flash`
- **エンドポイント**: `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent`
- **認証方式**: APIキー（クエリパラメータ）
- **バージョン**: v1beta

### 主要機能

1. **記事の関連性評価**: 0-100点のスコアリングシステム
2. **AI生成記事の判定**: 低品質なAI生成コンテンツの除外
3. **記事要約生成**: Discord Embed用の50-200文字の要約

---

## レート制限戦略

### 無料枠の制限

Gemini Flash APIの無料枠には以下の制限があります:

- **15 RPM** (Requests Per Minute): 1分あたり15リクエスト
- **1500 RPD** (Requests Per Day): 1日あたり1500リクエスト
- **1 TPM** (Tokens Per Minute): 1分あたり100万トークン

### 実装戦略

```go
// レート制限の設定
RequestInterval = 4 * time.Second  // 15 RPM = 4秒に1リクエスト
BurstLimit = 3                     // バースト3を許可
```

**設計理由**:

1. **平均間隔**: 15 RPM = 60秒 ÷ 15 = 4秒/リクエスト
2. **バースト許容**: 短期的なスパイク（連続3リクエスト）に対応
3. **自動待機**: `golang.org/x/time/rate`のLimiterが次のトークンまで自動的に待機

### レート制限の実装

```go
limiter := rate.NewLimiter(rate.Every(RequestInterval), BurstLimit)

// 各APIリクエスト前に待機
err := limiter.Wait(ctx)
if err != nil {
    return err
}
```

**利点**:

- 手動のリトライロジック不要
- 429エラーの事前防止
- コンテキストキャンセルに対応

---

## エラーハンドリング

### HTTPステータスコード

| コード | ステータス | 説明 | 対応 |
|-------|-----------|------|------|
| 200 | OK | 正常 | レスポンスをパース |
| 400 | Bad Request | 無効なリクエスト | エラーログ、記事をスキップ |
| 401 | Unauthorized | 認証エラー | 致命的エラー、処理を停止 |
| 429 | Too Many Requests | レート制限超過 | レート制限により防止される |
| 500 | Internal Server Error | サーバーエラー | エラーログ、記事をスキップ |

### FinishReason処理

Gemini APIのレスポンスには`finishReason`フィールドがあります:

```go
switch geminiResp.Candidates[0].FinishReason {
case "STOP":
    // 正常完了
case "MAX_TOKENS":
    // 最大トークン数に達した
    return fmt.Errorf("response truncated: max tokens limit reached")
case "SAFETY":
    // 安全フィルタによりブロック
    return fmt.Errorf("content blocked by safety filter")
case "RECITATION":
    // 既存コンテンツの再引用
    return fmt.Errorf("content blocked due to recitation")
default:
    // 予期しない理由
    return fmt.Errorf("unexpected finish reason: %s", ...)
}
```

**対応方針**:

- `STOP`: 正常処理を継続
- `MAX_TOKENS`: エラーとして扱い、記事をスキップ
- `SAFETY`: エラーとして扱い、記事をスキップ
- `RECITATION`: エラーとして扱い、記事をスキップ

---

## 記事評価ロジック

### スコアリング基準（加算方式、最大100点）

記事の評価は以下の5つのカテゴリで行われます:

#### 1. AI生成記事の判定（必須チェック）

- **人間による執筆**: 評価を継続
- **AI生成の可能性**: 即座に0点

**判定基準**:
- 過度に形式的で個性のない文体
- 具体的な実装や経験の欠如
- 表面的な情報の羅列のみ
- 表現が大袈裟で具体的でない

#### 2. トピックマッチング（最大30点）

- 3つ以上のトピックに詳細な実装例で言及: +30点
- 2つのトピックに詳細な実装例で言及: +20点
- 1つのトピックに詳細な実装例で言及: +15点
- 複数トピックに言及するが表面的: +10点
- 1つのトピックに軽く言及: +5点
- トピックに全く言及なし: +0点

#### 3. 内容の具体性（最大30点）

- 実際のコード例・コマンド・設定ファイルを複数含む: +30点
- 実装方法の詳細な手順とコード例を含む: +25点
- アーキテクチャ図や設計パターンの具体的な解説: +20点
- ベストプラクティスと理由の説明: +15点
- 概念的な説明と簡単な例: +10点
- 抽象的な概念の説明のみ: +5点

#### 4. 実用性（最大25点）

- 実際のプロジェクトで即座に適用可能な実装: +25点
- ステップバイステップのチュートリアル: +20点
- 実務で参考になる設計思想と具体例: +15点
- 参考情報としての価値あり: +10点
- 一般的な情報の紹介のみ: +5点

#### 5. 記事の深さ（最大15点）

- 包括的で詳細な解説（実質2000文字以上）: +15点
- 中程度の詳細な解説（実質1000-2000文字）: +10点
- 簡潔だが要点を押さえた解説（実質500-1000文字）: +7点
- 短い紹介記事（実質500文字未満）: +3点

### スコア区分の目安

- **80-100点**: 複数トピック + 詳細なコード例 + 即座に実用可能 + 包括的
- **60-79点**: 1-2トピック + 具体的な実装 + 実用的 + 詳細
- **40-59点**: トピック言及 + 概念説明 + やや実用的
- **0-39点**: トピック言及なし or 表面的 or AI生成

---

## プロンプトエンジニアリング

### 設計原則

1. **加算方式の採用**: 各評価項目の配点を明確化し、LLMの判断の一貫性を向上
2. **構造化JSON出力**: `responseMimeType: "application/json"`でパースエラーを防止
3. **具体的な判断基準**: 客観的に判断できる基準（コード例の有無など）を採用
4. **トピックの深さ重視**: 表面的な言及より詳細な実装例を高く評価
5. **文字制限の明示**: 要約を50-200文字に制限し、簡潔性を強制
6. **幻覚トピック禁止**: LLMがトピックを発明するのを防止

### 温度パラメータ

```go
Temperature = 0.3
```

**理由**: 一貫したスコアリングのために低く設定（範囲0-2）

### 最大出力トークン

```go
MaxOutputTokens = 500
```

**理由**: スコア+要約のJSON応答に十分な量

### プロンプトコンテンツの制限

```go
MaxPromptContentLength = 10000  // 文字
```

**理由**:
- Gemini Flash APIの入力トークン制限（約50kトークン）を考慮
- 記事本文を適切な長さに制限してコストを最適化
- 長大な記事でもレスポンス速度を維持

---

## データフロー

```
1. 記事を受け取る (Article)
2. プロンプトを構築 (buildEvaluationPrompt)
3. Gemini APIを呼び出し (GenerateContent)
4. レート制限を適用 (limiter.Wait)
5. HTTPリクエストを送信
6. レスポンスを受信
7. FinishReasonを検証
8. JSON応答をパース (EvaluationResult)
9. 評価結果を検証 (ValidateEvaluationResult)
10. ArticleEvaluationに変換
11. 却下理由を判定 (DetermineRejectionReason)
```

---

## パフォーマンス考慮事項

### トークン使用量

- **プロンプト**: 約1000-2000トークン（記事コンテンツ10,000文字）
- **応答**: 約100-200トークン（評価結果JSON）
- **合計**: 約1100-2200トークン/リクエスト

### 処理時間

- **レート制限待機**: 平均4秒/リクエスト
- **API応答時間**: 約2-5秒
- **合計**: 約6-9秒/記事

### 日次クォータ

- **1500 RPD制限**: 1日あたり最大1500記事を評価可能
- **想定記事数**: 100-200記事/日
- **クォータ使用率**: 約7-13%

---

## セキュリティ

### APIキー管理

- **保存場所**: Google Cloud Secret Manager
- **アクセス方法**: `internal/secrets`パッケージを使用
- **ローテーション**: 手動（必要に応じて）

### データプライバシー

- **送信データ**: 記事のタイトルと本文のみ
- **保存データ**: Geminiは送信されたデータを学習に使用しない（2024年時点）
- **ログ**: APIリクエストはログに記録されない

---

## トラブルシューティング

### よくある問題

#### 1. 429エラー（レート制限超過）

**症状**: `Resource has been exhausted (e.g. check quota).`

**原因**:
- レート制限の設定ミス
- 複数インスタンスの同時実行

**解決策**:
- レート制限の設定を確認（4秒間隔、バースト3）
- Cloud Functionsの並行実行数を1に制限

#### 2. 401エラー（認証失敗）

**症状**: `API key not valid`

**原因**:
- APIキーが無効または期限切れ
- Secret Managerからの取得失敗

**解決策**:
- Secret Managerの設定を確認
- APIキーを再生成して更新

#### 3. スコアの一貫性がない

**症状**: 同じような記事で大きく異なるスコア

**原因**:
- 温度パラメータが高すぎる
- プロンプトの曖昧性

**解決策**:
- 温度パラメータを0.3に維持
- プロンプトの判断基準を明確化

---

## 将来の改善案

### P2（次のイテレーション）

1. **リトライロジック実装**
   - 500エラー時の指数バックオフ
   - 最大3回の再試行

2. **プロンプトの外部ファイル化**
   - プロンプトテンプレートを`prompts/`ディレクトリに配置
   - A/Bテストとバージョン管理を容易に

3. **メトリクス収集**
   - API呼び出し回数
   - 平均レスポンス時間
   - エラー率

4. **キャッシュ機構**
   - 同一記事の再評価を防止
   - Redis等を使用したキャッシュ

---

## 参考資料

- [Gemini API ドキュメント](https://ai.google.dev/api/rest)
- [golang.org/x/time/rate パッケージ](https://pkg.go.dev/golang.org/x/time/rate)
- [contracts/gemini-api.md](../specs/001-rss-article-curator/contracts/gemini-api.md)

---

**最終更新**: 2025-11-08
